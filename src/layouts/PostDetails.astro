---
import Layout from "@/layouts/Layout.astro";
import Header from "@/components/sections/Header.astro";
import Footer from "@/components/sections/Footer.astro";
import Tag from "@/components/elements/Tag.astro";
import { type CollectionEntry } from "astro:content";
import { slugService } from "@/services/format/SlugService";
import ShareLinks from "@/components/socials/ShareLinks.astro";
import { SITE } from "@/config";
import Image from "@/components/elements/Image.astro";
import Blockquote from "@/components/elements/Blockquote.astro";
import { getLangFromUrl, useTranslations } from "@/i18n/utils";
import { Picture } from "astro:assets";
import ArticleMeta from "@/components/partials/ArticleMeta.astro";
import Paragraph from "@/components/elements/Paragraph.astro";
import { authorService } from "@/services/content/AuthorService";

interface PostProps {
  post: CollectionEntry<"blog">;
}

interface LayoutProps {
  title: string;
  author: string;
  heroImage: CollectionEntry<"blog">["data"]["heroImage"];
  description: string;
  pubDatetime: Date;
  modDatetime?: Date;
  canonicalURL?: string;
  ogImage: string;
  scrollSmooth: boolean;
}

const { post } = Astro.props as PostProps;

const {
  data: {
    title,
    author,
    heroImage,
    description,
    ogImage,
    canonicalURL,
    pubDatetime,
    modDatetime,
    categories,
    tags,
    // references,
  },
} = post;

const authorEntry = await authorService.getAuthorEntry(author);
// const reference = await getReference(title);
const { Content } = await post.render();

const ogImageUrl = typeof ogImage === "string" ? ogImage : ogImage?.src;
const ogUrl = new URL(
  ogImageUrl ?? `/posts/${slugService.slugifyStr(title)}.png`,
  Astro.url.origin
).href;

const layoutProps: LayoutProps = {
  title: `${title} | ${SITE.title}`,
  author: authorEntry?.data.name || SITE.author,
  heroImage,
  description,
  pubDatetime,
  modDatetime,
  canonicalURL,
  ogImage: ogUrl,
  scrollSmooth: true,
};

const components = { img: Image, blockquote: Blockquote, p: Paragraph };

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

// Generate unique view transition name for hero image
const heroImageTransitionName = heroImage
  ? `hero-image-${slugService.slugifyStr(title)}-${post.id}`
  : undefined;
---

<Layout {...layoutProps}>
  <!-- Reading Progress Bar -->
  <div
    class="progress-container fixed top-0 z-20 block h-1 w-full bg-transparent 2xl:hidden"
    role="progressbar"
    aria-label="Reading progress"
    aria-valuemin="0"
    aria-valuemax="100"
    aria-valuenow="0"
  >
    <div
      id="progress-top"
      class="h-1 w-0 rounded-full bg-gradient-to-r from-skin-accent/50 to-skin-accent"
    >
    </div>
  </div>

  <Header />

  <!-- Main Content Grid -->
  <div class="relative mx-auto mt-8 grid max-w-content grid-cols-12 gap-8">
    <!-- Main Content Area -->
    <main id="main-content" class="col-span-12 2xl:col-span-8 3xl:col-span-9">
      <!-- Categories -->
      <div class="mb-2 flex flex-wrap text-xs uppercase">
        {
          categories &&
            categories.map((category: string) => (
              <div
                transition:name={slugService.slugifyStr(title + category)}
                class="mb-1 mr-[0.125rem] inline-flex items-center text-sm font-medium text-skin-accent after:[&:not(:last-child)]:ml-[0.125rem] after:[&:not(:last-child)]:content-['|']"
                data-pagefind-filter={t("category.name")}
              >
                {category}
              </div>
            ))
        }
      </div>

      <!-- Title -->
      <h1
        transition:name={slugService.slugifyStr(title)}
        class="mb-4 text-xl font-semibold lg:text-3xl"
      >
        {title}
      </h1>

      <!-- Article Meta -->
      <ArticleMeta post={post} showAuthor={true} showReadingTime={true} />

      <!-- Hero Image -->
      {
        heroImage && (
          <Picture
            class="mx-auto mt-4 aspect-video"
            src={heroImage.src}
            alt={heroImage.alt}
            decoding="async"
            loading={"eager"}
            widths={[400, 800, 1200, 1600]}
            sizes="(max-width: 800px) 400px, (max-width: 1200px) 800px, (max-width: 1600px) 1200px, 1600px"
            formats={["avif", "webp"]}
            fallbackFormat="png"
            transition:name={heroImageTransitionName}
            data-pagefind-index-attrs="title,alt"
          />
        )
      }

      <!-- Article Content -->
      <article id="article" class="prose mx-auto mt-6 max-w-none">
        <Content components={components} />
      </article>

      <!-- References -->
      <!-- {references && references.length > 0 && <References references={references} />} -->

      <!-- Tags -->
      <ul class="my-8 flex flex-wrap gap-2" role="list" aria-label="Tags">
        {
          tags.map((tag: string) => (
            <Tag tag={slugService.slugifyStr(tag)} tagName={tag} />
          ))
        }
      </ul>

      <!-- Navigation and Share Links -->
      <div
        class="flex flex-col-reverse items-center justify-between gap-6 sm:flex-row-reverse sm:items-end sm:gap-4"
      >
        <button
          id="back-to-top"
          class="focus-outline flex items-center gap-2 whitespace-nowrap py-1 hover:opacity-75"
          aria-label={t("nav.backToTop")}
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="rotate-90"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <title>Back to top arrow</title>
            <path
              d="M13.293 6.293 7.586 12l5.707 5.707 1.414-1.414L10.414 12l4.293-4.293z"
            ></path>
          </svg>
          <span>{t("nav.backToTop")}</span>
        </button>

        <ShareLinks />
      </div>
    </main>

    <!-- Table of Contents Sidebar -->
    <aside
      data-pagefind-ignore="all"
      class="sticky top-24 hidden h-auto self-start rounded-lg bg-skin-card/5 p-4 shadow-sm 2xl:col-span-4 2xl:block 3xl:col-span-3"
      aria-label="Table of contents"
      style="position: sticky; height: calc(100vh - 120px);"
    >
      <!-- Mobile Progress Bar -->
      <div
        id="progress-mobile"
        class="fixed left-0 top-0 h-2 w-full bg-gradient-to-r from-orange-400/30 to-orange-400 md:hidden"
        role="progressbar"
        aria-label="Reading progress mobile"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="0"
      >
      </div>

      <!-- Desktop Progress Bar -->
      <div id="pin" class="hidden md:block">
        <div class="mx-4 overflow-hidden">
          <div
            id="progress-aside"
            class="h-px w-full bg-gradient-to-r from-skin-accent/50 to-skin-accent"
            role="progressbar"
            aria-label="Reading progress sidebar"
            aria-valuemin="0"
            aria-valuemax="100"
            aria-valuenow="0"
          >
          </div>
        </div>

        <!-- TOC Navigation -->
        <nav
          id="toc"
          class="mx-4 h-full rounded-lg bg-skin-card/30 px-4 py-6 shadow-md"
          aria-label="Table of contents"
          style="height: calc(100vh - 160px);"
        >
          <h2
            class="mb-4 text-base font-medium text-skin-base"
            id="toc-heading"
          >
            {t("toc.title")}
          </h2>
          <ul
            class="space-y-2 text-pretty text-sm transition duration-300 ease-in-out"
            role="list"
            aria-labelledby="toc-heading"
          >
          </ul>
        </nav>
      </div>
    </aside>
  </div>

  <Footer />

  <script>
    class TableOfContents {
      private observer: IntersectionObserver;
      private article: HTMLElement | null;
      private tocList: HTMLUListElement | null;
      private headings: HTMLElement[];

      constructor() {
        this.article = document.querySelector<HTMLElement>("#article");
        this.tocList = document.querySelector<HTMLUListElement>("#toc ul");
        this.headings = Array.from(
          this.article?.querySelectorAll("h2, h3, h4") || []
        );
        // this.headings = Array.from(
        //   this.article?.querySelectorAll("h2, h3, h4, h5, h6") || []
        // );

        this.observer = new IntersectionObserver(
          (entries: IntersectionObserverEntry[]) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                this.setSelectedLinkById(entry.target.id);
              }
            });
          },
          {
            root: null,
            rootMargin: "0px 0px -40% 0px",
            threshold: [0.1, 0.5, 1.0],
          }
        );

        this.initialize();
      }

      private setSelectedLinkById(selectedId: string): void {
        const listItems = document.querySelectorAll<HTMLLIElement>("#toc li");
        listItems.forEach(item => item.classList.remove("selected"));

        const selectedLink = document.querySelector<HTMLAnchorElement>(
          `#toc a[href="#${selectedId}"]`
        );
        const listItem = selectedLink?.parentElement;
        if (listItem) {
          listItem.classList.add("selected");
          this.scrollIntoViewIfNeeded(listItem);
        }
      }

      private scrollIntoViewIfNeeded(element: HTMLElement): void {
        const container = document.querySelector<HTMLElement>("#toc");
        if (!container) return;

        const { top: containerTop, bottom: containerBottom } =
          container.getBoundingClientRect();
        const { top: elementTop, bottom: elementBottom } =
          element.getBoundingClientRect();

        if (elementBottom > containerBottom || elementTop < containerTop) {
          element.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }
      }

      private createSvgElement(): SVGElement {
        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.classList.add("w-0", "h-0", "flex-none", "text-skin-accent");
        svg.setAttribute("fill", "none");
        svg.setAttribute("viewBox", "0 0 24 24");
        svg.setAttribute("stroke-width", "2");
        svg.setAttribute("stroke", "currentColor");
        svg.setAttribute("aria-hidden", "true");
        svg.innerHTML =
          '<title>Section indicator</title><path stroke-linecap="round" stroke-linejoin="round" d="m12.75 15 3-3m0 0-3-3m3 3h-7.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />';
        return svg;
      }

      private createLink(heading: HTMLElement): HTMLAnchorElement {
        const link = document.createElement("a");

        // Ensure the heading has a valid ID and accessible name
        if (!heading.id) {
          // Get accessible name from heading
          const headingText = this.getAccessibleName(heading);
          heading.id = this.generateSafeId(headingText);
        }

        link.href = `#${heading.id}`;

        // Get only the direct text content, not including nested elements
        // This prevents duplication of text in headings with nested elements
        const textNodes = Array.from(heading.childNodes)
          .filter(node => node.nodeType === Node.TEXT_NODE)
          .map(node => node.textContent?.trim())
          .filter(text => text) // Filter out empty strings
          .join(" ");

        // If there's direct text content, use it; otherwise fall back to textContent
        const linkText = textNodes || heading.textContent?.trim() || "";

        // Ensure the link has an accessible name (inner text)
        link.textContent = linkText;

        // Add comprehensive accessibility attributes
        // Note: aria-label is not needed if the link has proper inner text
        // but we add it for additional context
        link.setAttribute("aria-label", `Jump to section: ${linkText}`);
        link.setAttribute("aria-describedby", `toc-heading`);

        // Add ARIA current for the active item
        if (window.location.hash === `#${heading.id}`) {
          link.setAttribute("aria-current", "location");
        }

        // Add smooth scrolling behavior with error handling
        link.addEventListener("click", e => {
          e.preventDefault();
          const targetId = link.getAttribute("href")?.substring(1);
          if (targetId) {
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              try {
                // Smooth scroll to the target
                targetElement.scrollIntoView({
                  behavior: "smooth",
                  block: "start",
                });

                // Update URL without causing a page jump
                history.pushState(null, "", link.href);

                // Set focus to the target for accessibility
                // Only add tabindex temporarily and remove it after focus
                const hadTabIndex = targetElement.hasAttribute("tabindex");
                const oldTabIndex = targetElement.getAttribute("tabindex");

                targetElement.setAttribute("tabindex", "-1");
                targetElement.focus({ preventScroll: true });

                // Remove the tabindex after a short delay to prevent leaving
                // non-interactive elements permanently in the tab order
                setTimeout(() => {
                  if (hadTabIndex && oldTabIndex) {
                    targetElement.setAttribute("tabindex", oldTabIndex);
                  } else {
                    targetElement.removeAttribute("tabindex");
                  }
                }, 100);

                // Announce to screen readers
                const announcement = document.createElement("div");
                announcement.setAttribute("aria-live", "polite");
                announcement.setAttribute("class", "sr-only");
                announcement.textContent = `Navigated to section: ${linkText}`;
                document.body.appendChild(announcement);
                setTimeout(() => document.body.removeChild(announcement), 1000);

                // Update selected state in TOC
                this.setSelectedLinkById(targetId);
              } catch (error) {
                console.error(
                  `Error navigating to section ${targetId}:`,
                  error
                );
                // Fallback to standard navigation if smooth scroll fails
                window.location.hash = targetId;
              }
            } else {
              console.warn(`Target element with ID ${targetId} not found`);
            }
          }
        });

        return link;
      }

      private createListItem(heading: HTMLElement): HTMLLIElement {
        const listItem = document.createElement("li");
        listItem.className = `toc-level-${heading.tagName.toLowerCase()}`;

        const svg = this.createSvgElement();
        const link = this.createLink(heading);

        listItem.appendChild(svg);
        listItem.appendChild(link);

        return listItem;
      }

      private initialize(): void {
        if (!this.tocList || !this.headings.length) return;

        // Ensure headings have IDs for proper linking
        this.headings.slice(1).forEach((heading, index) => {
          // Generate an ID if the heading doesn't have one
          if (!heading.id) {
            const headingText =
              heading.textContent?.trim() || `heading-${index}`;
            heading.id = this.generateSafeId(headingText);
          }

          const listItem = this.createListItem(heading);
          this.tocList?.appendChild(listItem);

          // Only observe elements that exist in the DOM
          try {
            this.observer.observe(heading);
          } catch (error) {
            console.error(`Failed to observe heading: ${heading.id}`, error);
          }
        });

        // Add keyboard navigation for accessibility
        this.addKeyboardNavigation();

        window.addEventListener("beforeunload", () => {
          this.observer.disconnect();
        });
      }

      /**
       * Gets the accessible name of an element
       * @param element The element to get the accessible name from
       * @returns The accessible name
       */
      private getAccessibleName(element: HTMLElement): string {
        // Check for aria-label
        const ariaLabel = element.getAttribute("aria-label");
        if (ariaLabel) return ariaLabel;

        // Check for aria-labelledby
        const ariaLabelledBy = element.getAttribute("aria-labelledby");
        if (ariaLabelledBy) {
          const labelElement = document.getElementById(ariaLabelledBy);
          if (labelElement && labelElement.textContent) {
            return labelElement.textContent.trim();
          }
        }

        // Check for img with alt text
        const img = element.querySelector("img");
        if (img) {
          const altText = img.getAttribute("alt");
          if (altText) return altText;
        }

        // Check for SVG with title
        const svg = element.querySelector("svg");
        if (svg) {
          const titleElement = svg.querySelector("title");
          if (titleElement && titleElement.textContent) {
            return titleElement.textContent.trim();
          }
        }

        // Fall back to inner text
        return element.textContent?.trim() || "section";
      }

      /**
       * Generates a safe ID from heading text
       * @param text The heading text
       * @returns A safe ID string
       */
      private generateSafeId(text: string): string {
        // Convert to lowercase, replace spaces with hyphens, remove special chars
        return (
          text
            .toLowerCase()
            .replace(/\s+/g, "-")
            .replace(/[^\w-]/g, "")
            .replace(/--+/g, "-")
            .replace(/^-+|-+$/g, "") || "section"
        );
      }

      /**
       * Adds keyboard navigation to the TOC for accessibility
       */
      private addKeyboardNavigation(): void {
        if (!this.tocList) return;

        // Add keyboard event listeners to each link instead of the list
        const links = Array.from(this.tocList.querySelectorAll("a"));

        links.forEach((link, index) => {
          // Ensure links are properly focusable (they are by default)
          link.addEventListener("keydown", event => {
            const items = links;
            if (!items.length) return;

            switch (event.key) {
              case "ArrowDown":
                event.preventDefault();
                const nextIndex = index < items.length - 1 ? index + 1 : 0;
                (items[nextIndex] as HTMLElement).focus();
                break;
              case "ArrowUp":
                event.preventDefault();
                const prevIndex = index > 0 ? index - 1 : items.length - 1;
                (items[prevIndex] as HTMLElement).focus();
                break;
              case "Home":
                event.preventDefault();
                (items[0] as HTMLElement).focus();
                break;
              case "End":
                event.preventDefault();
                (items[items.length - 1] as HTMLElement).focus();
                break;
            }
          });
        });

        // Add ARIA role to the list for better screen reader support
        this.tocList.setAttribute("role", "navigation");
      }
    }

    class ScrollProgress {
      private progressBars: HTMLElement[];
      private article: HTMLElement | null;
      private ticking: boolean;

      constructor() {
        this.progressBars = Array.from(
          document.querySelectorAll<HTMLElement>(
            "#progress-top, #progress-aside, #progress-mobile"
          )
        );
        this.article = document.querySelector("article");
        this.ticking = false;
      }

      public update(): void {
        if (this.ticking) return;

        this.ticking = true;
        requestAnimationFrame(() => {
          if (!this.article) return;

          const scrollPosition = window.scrollY;
          const windowHeight = window.innerHeight;
          const documentHeight =
            document.documentElement.scrollHeight - windowHeight;

          const progress = Math.max(
            0,
            Math.min(100, (scrollPosition / documentHeight) * 100)
          );

          this.progressBars.forEach(bar => {
            bar.style.width = `${progress}%`;
            bar.setAttribute("aria-valuenow", progress.toString());
          });

          this.ticking = false;
        });
      }
    }

    class BackToTopButton {
      private button: HTMLElement | null;

      constructor() {
        this.button = document.getElementById("back-to-top");
        this.initialize();
      }

      private initialize(): void {
        this.button?.addEventListener("click", () => {
          window.scrollTo({ top: 0, behavior: "smooth" });
        });
      }
    }

    document.addEventListener("astro:page-load", () => {
      const scrollProgress = new ScrollProgress();
      window.addEventListener("scroll", () => scrollProgress.update(), {
        passive: true,
      });

      new TableOfContents();
      new BackToTopButton();
    });
  </script>

  <style is:global lang="postcss">
    /* Screen reader only class for accessibility */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }
    
    main {
      @apply mx-auto w-full max-w-none px-4 pb-12;
    }

    #toc {
      /* Fixed height TOC with internal scrolling */
      height: calc(100vh - 160px);
      max-height: calc(100vh - 160px);
      overflow-y: auto;
      
      /* Ultra-thin scrollbar */
      scrollbar-width: thin;
      scrollbar-color: var(--color-accent) transparent;

      &::-webkit-scrollbar {
        width: 3px; /* Make scrollbar as small as possible */
      }

      &::-webkit-scrollbar-track {
        @apply bg-transparent;
      }

      &::-webkit-scrollbar-thumb {
        @apply rounded-full;
        background-color: var(--color-accent); /* Use primary color */
      }

      li {
        @apply flex items-center text-sm leading-4 text-skin-base opacity-80 my-1;
        transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);

        &.selected {
          @apply opacity-100 text-skin-accent;
          svg {
            @apply mr-2 h-4 w-4;
          }
        }

        svg {
          @apply h-0 w-0;
          transition: all 400ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        a {
          @apply block py-1 hover:text-skin-accent;
          transition: color 200ms ease-in-out;
        }
      }

      .toc-level-h2 {
        @apply ml-2;
      }

      .toc-level-h3 {
        @apply ml-4;
      }

      .toc-level-h4 {
        @apply ml-6;
      }
    }
  </style>
</Layout>
