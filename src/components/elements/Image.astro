---
import type { ImageMetadata } from "astro";

type Props = {
  /** Image source URL or metadata */
  src: string | ImageMetadata;
  /** Alt text for accessibility */
  alt: string;
  /** Optional caption */
  title?: string;
  /** Optional aspect ratio */
  aspectRatio?: "auto" | "square" | "video" | "portrait" | "ultrawide";
  /** Optional loading strategy */
  loading?: "lazy" | "eager";
  /** Optional visual style */
  style?: "default" | "polaroid" | "bordered" | "floating" | "glass";
  /** Optional animation effect */
  effect?: "none" | "zoom" | "parallax" | "tilt";
  /** Optional position */
  position?: "left" | "right" | "center" | "full";
};

const {
  src: srcProp,
  alt,
  title,
  aspectRatio = "auto",
  loading = "lazy",
  style = "default",
  effect = "none",
  position = "center",
}: Props = Astro.props;

// Parse position from title if provided (legacy support)
let finalPosition = position;
let finalTitle = title;

if (title) {
  const controlChar = title.charAt(0);
  const directionMap: Record<string, string> = {
    ">": "right",
    "<": "left",
    "|": "center",
    _: "full",
  };

  if (directionMap[controlChar]) {
    finalPosition = directionMap[controlChar] as typeof position;
    finalTitle = title.slice(1);
  }
}

// For MDX files, we'll use the img tag directly with the provided src
let src: string;

if (typeof srcProp === "string") {
  // Use the string directly
  src = srcProp;
} else {
  // If it's an ImageMetadata object, try to extract the src property
  try {
    // @ts-ignore - We know this might not be safe, but it's a fallback
    src = srcProp.src || "";
  } catch (error) {
    console.error("Error extracting src from ImageMetadata:", error);
    src = "";
  }
}

// Map aspect ratios to CSS classes
const aspectRatioClasses = {
  auto: "",
  square: "aspect-square",
  video: "aspect-video",
  portrait: "aspect-[3/4]",
  ultrawide: "aspect-[21/9]",
};

// Map styles to CSS classes
const styleClasses = {
  default: "img-default",
  polaroid: "img-polaroid",
  bordered: "img-bordered",
  floating: "img-floating",
  glass: "img-glass",
};

// Map effects to data attributes and CSS classes
const effectClasses = {
  none: "",
  zoom: "img-zoom",
  parallax: "img-parallax",
  tilt: "img-tilt",
};

// Map positions to CSS classes
const positionClasses = {
  left: "img-left",
  right: "img-right",
  center: "img-center",
  full: "img-full",
};

// Determine animation based on position
const animationDirection =
  finalPosition === "left"
    ? "fade-right"
    : finalPosition === "right"
      ? "fade-left"
      : "fade-up";
---

<figure
  class:list={[
    "image-container",
    positionClasses[finalPosition],
    effectClasses[effect],
  ]}
  data-aos={animationDirection}
  data-effect={effect}
>
  <div
    class:list={[
      "image-wrapper",
      styleClasses[style],
      aspectRatioClasses[aspectRatio],
    ]}
  >
    <img src={src} alt={alt} loading={loading} class="image" />

    {effect === "parallax" && <div class="parallax-overlay" />}
  </div>

  {finalTitle && <figcaption class="image-caption">{finalTitle}</figcaption>}
</figure>

<style>
  /* Base container styles */
  .image-container {
    @apply relative mx-auto my-6 max-w-content;
  }

  /* Image wrapper styles */
  .image-wrapper {
    @apply relative overflow-hidden;
  }

  /* Base image styles */
  .image {
    @apply h-full w-full object-cover transition-all duration-500;
  }

  /* Position variants */
  .img-left {
    @apply float-left mr-8 md:max-w-[50%] lg:max-w-[40%];
  }

  .img-right {
    @apply float-right ml-8 md:max-w-[50%] lg:max-w-[40%];
  }

  .img-center {
    @apply mx-auto block md:max-w-[70%];
  }

  .img-full {
    @apply mx-auto block w-full;
  }

  /* Style variants */
  .img-default {
    @apply rounded-lg shadow-lg;
  }

  .img-polaroid {
    @apply rounded-sm bg-white p-2 shadow-xl;
    transform: rotate(var(--rotation, 0deg));
    --rotation: calc(random() * 4deg - 2deg);
  }

  .img-bordered {
    @apply rounded-none border-4 border-skin-accent/30 p-1;
  }

  .img-floating {
    @apply rounded-lg shadow-xl;
    box-shadow:
      0 10px 15px -3px rgba(0, 0, 0, 0.1),
      0 4px 6px -2px rgba(0, 0, 0, 0.05),
      0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  .img-glass {
    @apply rounded-xl;
    box-shadow:
      0 4px 6px -1px rgba(0, 0, 0, 0.1),
      0 2px 4px -1px rgba(0, 0, 0, 0.06);
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* Effect variants */
  .img-zoom {
    @apply overflow-hidden;
  }

  .img-zoom .image {
    transition: transform 0.5s ease;
  }

  .img-zoom:hover .image {
    transform: scale(1.05);
  }

  .img-parallax {
    @apply overflow-hidden;
  }

  .parallax-overlay {
    @apply absolute inset-0 bg-gradient-to-t from-black/20 to-transparent opacity-0 transition-opacity duration-300;
  }

  .img-parallax:hover .parallax-overlay {
    @apply opacity-100;
  }

  .img-tilt {
    transition: transform 0.3s ease;
  }

  .img-tilt:hover {
    transform: perspective(1000px) rotateX(2deg) rotateY(-2deg);
  }

  /* Caption styles */
  .image-caption {
    @apply mt-2 text-center text-sm font-medium text-skin-base opacity-80;
  }

  .img-left .image-caption {
    @apply text-left;
  }

  .img-right .image-caption {
    @apply text-right;
  }

  /* Dark mode adjustments */
  :global(html[data-theme="dark"]) .img-polaroid {
    @apply bg-skin-card;
  }

  :global(html[data-theme="dark"]) .img-glass {
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }
</style>

<script>
  // Handle parallax effect
  document.addEventListener("DOMContentLoaded", () => {
    const parallaxImages = document.querySelectorAll(".img-parallax .image");

    if (parallaxImages.length > 0) {
      window.addEventListener("scroll", () => {
        parallaxImages.forEach(img => {
          if (img instanceof HTMLElement) {
            const rect = img.getBoundingClientRect();
            const windowHeight = window.innerHeight;

            if (rect.top < windowHeight && rect.bottom > 0) {
              const scrollPosition = (rect.top - windowHeight) / 5;
              img.style.transform = `translateY(${scrollPosition}px)`;
            }
          }
        });
      });
    }

    // Handle tilt effect
    const tiltImages = document.querySelectorAll(".img-tilt");

    tiltImages.forEach(container => {
      container.addEventListener("mousemove", e => {
        if (e instanceof MouseEvent && container instanceof HTMLElement) {
          const rect = container.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const centerX = rect.width / 2;
          const centerY = rect.height / 2;

          const rotateX = (y - centerY) / 20;
          const rotateY = (centerX - x) / 20;

          container.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        }
      });

      container.addEventListener("mouseleave", () => {
        if (container instanceof HTMLElement) {
          container.style.transform =
            "perspective(1000px) rotateX(0) rotateY(0)";
        }
      });
    });
  });
</script>
