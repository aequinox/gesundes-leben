---
/**
 * List Component
 *
 * A component for displaying structured lists with optional introductions
 * and decorative elements. Supports custom styling and accessibility features.
 *
 * @component
 * @example
 * ```astro
 * <List
 *   title="Main Title"
 *   items={[
 *     { intro: "First", content: "Content 1" },
 *     { content: "Content 2" }
 *   ]}
 * />
 * ```
 */

interface Item {
  /** Optional introduction text */
  intro?: string;
  /** Main content text */
  content: string;
}

interface Props {
  /** Section title */
  title?: string;
  /** Array of list items */
  items: Item[];
  /** Optional CSS classes for the title */
  titleClasses?: string;
}

const { title, items, titleClasses = "" }: Props = Astro.props;

// Memoize common class names
const sectionClasses = [
  "relative mx-auto -mb-4 mt-8",
  "box-border overflow-hidden hyphens-auto",
  "rounded-lg shadow-sm",
  "bg-gradient-to-b from-skin-card via-skin-card/50 to-transparent",
  "p-6 text-lg",
  "backdrop-blur-sm",
].join(" ");

const titleBaseClasses = [
  "text-2xl font-medium text-skin-accent mb-4",
  "border-b border-skin-accent/20 pb-2",
  titleClasses,
]
  .filter(Boolean)
  .join(" ");

const listClasses = ["prose mx-auto w-full max-w-content px-4"].join(" ");

// Generate unique IDs for accessibility
const sectionId = `list-section-${Math.random().toString(36).substring(2, 9)}`;
const titleId = title ? `${sectionId}-title` : undefined;
---

<section class={sectionClasses} data-aos="fade-up" aria-labelledby={titleId}>
  <!-- Decorative wave divider -->
  <div class="wave-divider" aria-hidden="true">
    <svg
      data-name="Layer 1"
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 1200 120"
      preserveAspectRatio="none"
    >
      <path
        d="M985.66,92.83C906.67,72,823.78,31,743.84,14.19c-82.26-17.34-168.06-16.33-250.45.39-57.84,11.73-114,31.07-172,41.86A600.21,600.21,0,0,1,0,27.35V120H1200V95.8C1132.19,118.92,1055.71,111.31,985.66,92.83Z"
        class="shape-fill"></path>
    </svg>
  </div>

  {
    title && (
      <div class={titleBaseClasses} id={titleId}>
        {title}
      </div>
    )
  }

  <div class={listClasses}>
    <ul class="mb-20" role="list">
      {
        items.map((item: Item, index) => (
          <li data-index={index} class="list-item">
            {item.intro && (
              <strong class="font-semibold">{item.intro}:&nbsp;</strong>
            )}
            <span class="item-content">{item.content}</span>
          </li>
        ))
      }
    </ul>
  </div>
</section>

<style>
  /* Wave divider styles */
  .wave-divider {
    @apply absolute bottom-0 left-0 w-[calc(100%+1.5px)] rotate-180 transform overflow-hidden leading-none;
  }

  .wave-divider svg {
    @apply relative block h-16 w-full rotate-180 overflow-hidden;
  }

  .wave-divider .shape-fill {
    @apply fill-skin-fill;
  }

  /* List styles */
  ul {
    @apply list-none pl-0 space-y-1;
  }

  li {
    @apply relative pl-8 py-1 transition-all duration-300 ease-in-out;
    @apply flex items-start;
  }

  /* Remove the bullet point we were adding */
  li::before {
    content: none;
  }

  .item-content {
    @apply leading-normal;
  }

  /* Staggered animation for list items */
  .list-item {
    opacity: 0;
    transform: translateY(10px);
    animation: fadeIn 0.5s ease-out forwards;
    animation-delay: calc(var(--index, 0) * 100ms);
  }

  @keyframes fadeIn {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Set animation delay based on index */
  li[data-index="0"] {
    --index: 0;
  }
  li[data-index="1"] {
    --index: 1;
  }
  li[data-index="2"] {
    --index: 2;
  }
  li[data-index="3"] {
    --index: 3;
  }
  li[data-index="4"] {
    --index: 4;
  }
  li[data-index="5"] {
    --index: 5;
  }
  li[data-index="6"] {
    --index: 6;
  }
  li[data-index="7"] {
    --index: 7;
  }
  li[data-index="8"] {
    --index: 8;
  }
  li[data-index="9"] {
    --index: 9;
  }
  li[data-index="10"] {
    --index: 10;
  }
  li[data-index="11"] {
    --index: 11;
  }
  li[data-index="12"] {
    --index: 12;
  }
  li[data-index="13"] {
    --index: 13;
  }
  li[data-index="14"] {
    --index: 14;
  }
  li[data-index="15"] {
    --index: 15;
  }
  li[data-index="16"] {
    --index: 16;
  }
  li[data-index="17"] {
    --index: 17;
  }
  li[data-index="18"] {
    --index: 18;
  }
  li[data-index="19"] {
    --index: 19;
  }

  /* Focus styles */
  section:focus-within {
    @apply ring-2 ring-skin-accent ring-offset-2;
  }

  /* Animation styles */
  [data-aos] {
    @apply opacity-0 transition-all duration-500;
  }

  [data-aos].aos-animate {
    @apply opacity-100;
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    section,
    [data-aos] {
      @apply transform-none opacity-100 transition-none;
    }
  }

  /* Print styles */
  @media print {
    section {
      @apply break-inside-avoid bg-transparent shadow-none;
    }

    .wave-divider {
      @apply hidden;
    }
  }

  /* High contrast mode */
  @media (forced-colors: active) {
    section {
      @apply border border-[CanvasText];
    }

    li::before {
      @apply bg-[CanvasText];
    }
  }

  /* Dark mode adjustments */
  :global(.dark) section {
    @apply bg-skin-card/5;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    section {
      @apply p-4;
    }

    .wave-divider svg {
      @apply h-12;
    }
  }
</style>

<script>
  /**
   * Enhances list sections with animation on scroll
   */
  function setupList() {
    const sections = document.querySelectorAll("[data-aos]");

    if (!("IntersectionObserver" in window)) {
      sections.forEach(section => section.classList.add("aos-animate"));
      return;
    }

    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add("aos-animate");
            observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: "50px",
        threshold: 0.1,
      }
    );

    sections.forEach(section => observer.observe(section));

    // Cleanup function
    return () => {
      sections.forEach(section => observer.unobserve(section));
      observer.disconnect();
    };
  }

  // Initialize on page load
  let cleanup = setupList();

  // Re-initialize after Astro page transitions
  document.addEventListener("astro:after-swap", () => {
    if (cleanup) cleanup();
    cleanup = setupList();
  });

  // Cleanup on page unload
  document.addEventListener("astro:before-swap", () => {
    if (cleanup) cleanup();
  });
</script>
