---
/**
 * Header Component
 *
 * A modern, accessible header component that provides site-wide navigation and user
 * interaction features. Built with performance and user experience in mind.
 *
 * Features:
 * - Responsive design with mobile-first approach
 * - Enhanced accessibility with ARIA attributes and keyboard navigation
 * - Smooth animations with reduced motion support
 * - Internationalization support
 * - Print and high contrast mode optimizations
 *
 * @component
 * @example
 * ```astro
 * <Header activeNav="posts" />
 * ```
 */

import { getLangFromUrl, useTranslations } from "@/i18n/utils";
import Navigation from "@/components/sections/Navigation.astro";
import type { NavigationLink } from "@/data/navigation";

// Type-safe component props
interface Props {
  /** Currently active navigation item for highlighting */
  activeNav?: NavigationLink;
}

const { activeNav }: Props = Astro.props;

// Internationalization setup
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

// Pre-compute translated strings for performance
const i18nStrings = {
  skipToContent: t("nav.skipToContent"),
  mainHeader: t("nav.mainNavigation"),
} as const;

// Utility function to combine Tailwind classes
const tw = (...classes: string[]) => classes.filter(Boolean).join(" ");

// Component-specific class compositions
const skipLinkClasses = tw(
  "absolute -top-full left-16 z-50",
  "bg-skin-accent px-3 py-2 text-skin-inverted",
  "transition-transform duration-300 ease-in-out focus:translate-y-24",
  "rounded-b-lg shadow-lg",
  "focus:outline-none focus:ring-2 focus:ring-skin-accent focus:ring-offset-2"
);
---

<header
  class="sticky top-0 z-10 h-24 w-full transform"
  role="banner"
  aria-label={i18nStrings.mainHeader}
>
  {/* Skip to content link - Accessibility feature */}
  <a
    id="skip-to-content"
    href="#main-content"
    class={skipLinkClasses}
    aria-label={i18nStrings.skipToContent}
  >
    {i18nStrings.skipToContent}
  </a>

  {/* Main navigation component */}
  <Navigation activeNav={activeNav} />
</header>

<style>
  /* Base styles with modern glass effect and theme transition handling */
  header {
    @apply bg-transparent;
    /* Optimize transitions for better performance */
    @apply will-change-transform;
    @apply transform-gpu;
    /* Smoother theme transitions */
    @apply transition-[background-color,border-color,box-shadow] duration-150 ease-in-out;
  }

  /* Enhanced glass effect on scroll with optimized transitions */
  header.scrolled {
    @apply bg-skin-fill/95;
    @apply shadow-md;
  }

  /* Skip link styles with improved accessibility and consistent theming */
  #skip-to-content {
    @apply focus:shadow-lg;
    @apply focus:outline-none focus:ring-2 focus:ring-skin-accent focus:ring-offset-2;
    @apply bg-skin-accent text-skin-inverted;
  }

  /* Reduced motion preferences - Disable non-essential animations */
  @media (prefers-reduced-motion: reduce) {
    header,
    #skip-to-content {
      @apply transform-none transition-none;
    }
  }

  /* Print optimization - Hide header when printing */
  @media print {
    header {
      @apply hidden;
    }
  }

  /* High contrast mode support with improved visibility */
  @media (forced-colors: active) {
    header {
      @apply border-b-2 border-[CanvasText];
      @apply shadow-none;
      forced-color-adjust: none;
    }
  }

  /* Dark mode optimizations with smoother transitions */
  :global(.dark) header {
    @apply bg-transparent;
  }

  /* Prevent FOUC during theme transitions */
  :root[data-theme-loading] header {
    @apply transition-none;
  }
</style>

<!-- Theme initialization script - Prevent FOUC -->
<script is:inline>
  (function () {
    // Get theme from localStorage or system preference
    const getTheme = () => {
      if (
        typeof localStorage !== "undefined" &&
        localStorage.getItem("theme")
      ) {
        return localStorage.getItem("theme");
      }
      return window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light";
    };

    // Apply theme immediately before page renders
    const theme = getTheme();
    document.documentElement.classList[theme === "dark" ? "add" : "remove"](
      "dark"
    );

    // Mark as loading to prevent transition flicker
    document.documentElement.setAttribute("data-theme-loading", "");

    // Remove loading state after a short delay
    window.addEventListener("load", () => {
      setTimeout(() => {
        document.documentElement.removeAttribute("data-theme-loading");
      }, 50);
    });
  })();
</script>

<script>
  /**
   * HeaderController class
   *
   * Manages header behavior with optimized performance and theme handling.
   * Features:
   * - Smooth scroll-based animations using IntersectionObserver
   * - Optimized theme transitions
   * - Enhanced keyboard navigation
   * - Memory leak prevention
   * - Proper cleanup on page transitions
   */
  class HeaderController {
    private static readonly SCROLL_THRESHOLD = 50; // px
    // private static readonly ANIMATION_DURATION = 150; // ms - reduced for smoother feel
    private static readonly DEBOUNCE_DELAY = 10; // ms

    private header: HTMLElement | null;
    private skipLink: HTMLElement | null;
    private lastScroll: number;
    private scrollTimeout: number | null;
    private observer: IntersectionObserver | null;
    private resizeObserver: ResizeObserver | null;
    private themeChangeHandler: (() => void) | null;

    constructor() {
      // Initialize elements with error handling
      this.header = document.querySelector("header");
      this.skipLink = document.getElementById("skip-to-content");
      this.lastScroll = window.scrollY;
      this.scrollTimeout = null;
      this.observer = null;
      this.resizeObserver = null;
      this.themeChangeHandler = null;

      if (!this.header || !this.skipLink) {
        console.warn("[HeaderController] Required elements not found");
        return;
      }

      // Initialize with performance optimizations
      requestAnimationFrame(() => this.init());
    }

    private init(): void {
      this.setupScrollObserver();
      this.setupResizeObserver();
      this.setupEventListeners();
      this.setupThemeChangeHandler();
    }

    /**
     * Sets up the Intersection Observer for scroll-based animations
     * with optimized performance and reduced jank
     */
    private setupScrollObserver(): void {
      if (!this.header) return;

      const options = {
        threshold: [0, 0.5, 1],
        rootMargin: `-${HeaderController.SCROLL_THRESHOLD}px 0px 0px 0px`,
      };

      this.observer = new IntersectionObserver(entries => {
        // Use requestAnimationFrame for smooth class toggling
        requestAnimationFrame(() => {
          entries.forEach(entry => {
            if (this.header) {
              this.header.classList.toggle("scrolled", !entry.isIntersecting);
            }
          });
        });
      }, options);

      // Create and observe sentinel element
      const sentinel = document.createElement("div");
      sentinel.style.cssText = "height: 1px; pointer-events: none; opacity: 0;";
      document.body.prepend(sentinel);
      this.observer.observe(sentinel);
    }

    /**
     * Sets up ResizeObserver to handle header adjustments
     * when window size changes
     */
    private setupResizeObserver(): void {
      if (!this.header) return;

      const handleResize = () => {
        if (this.header) {
          // Recalculate header properties on resize
          this.header.style.setProperty(
            "--header-height",
            `${this.header.offsetHeight}px`
          );
        }
      };

      this.resizeObserver = new ResizeObserver(
        this.debounce(handleResize, HeaderController.DEBOUNCE_DELAY)
      );

      this.resizeObserver.observe(this.header);
    }

    /**
     * Handles theme changes to prevent FOUC and ensure smooth transitions
     */
    private setupThemeChangeHandler(): void {
      if (!this.header) return;

      this.themeChangeHandler = () => {
        // Temporarily disable transitions during theme change
        this.header?.style.setProperty("transition", "none");
        requestAnimationFrame(() => {
          this.header?.style.removeProperty("transition");
        });
      };

      // Listen for theme changes
      document.addEventListener("theme-change", this.themeChangeHandler);
    }

    /**
     * Optimized scroll handler using RAF and transform
     * for better performance
     */
    private handleScroll = (): void => {
      if (!this.header) return;

      const currentScroll = window.scrollY;
      const isScrollingDown = currentScroll > this.lastScroll;

      requestAnimationFrame(() => {
        if (!this.header) return;

        // Use transform for GPU-accelerated animations
        if (
          isScrollingDown &&
          currentScroll > HeaderController.SCROLL_THRESHOLD
        ) {
          this.header.style.transform = "translateY(-100%)";
        } else {
          this.header.style.transform = "translateY(0)";
        }
      });

      this.lastScroll = currentScroll;
    };

    private handleSkipLink = (e: KeyboardEvent): void => {
      if (e.key !== "Enter") return;

      e.preventDefault();
      const mainContent = document.getElementById("main-content");

      if (mainContent) {
        mainContent.focus();
        mainContent.scrollIntoView({
          behavior: "smooth",
          block: "start",
        });
      }
    };

    private setupEventListeners(): void {
      if (!this.header || !this.skipLink) return;

      // Optimized scroll handling with passive listener
      window.addEventListener(
        "scroll",
        () => {
          if (this.scrollTimeout) {
            cancelAnimationFrame(this.scrollTimeout);
          }
          this.scrollTimeout = requestAnimationFrame(this.handleScroll);
        },
        { passive: true }
      );

      // Keyboard navigation
      this.skipLink.addEventListener("keydown", this.handleSkipLink);
    }

    /**
     * Utility method to debounce function calls
     */
    // eslint-disable-next-line no-unused-vars
    private debounce<T extends (...args: unknown[]) => void>(
      fn: T,
      delay: number
    ): T {
      let timeoutId: ReturnType<typeof setTimeout>;
      const debouncedFn = (...args: Parameters<T>) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(null, args), delay);
      };
      return debouncedFn as T;
    }

    /**
     * Comprehensive cleanup to prevent memory leaks
     */
    public cleanup(): void {
      // Remove event listeners
      window.removeEventListener("scroll", this.handleScroll);
      this.skipLink?.removeEventListener("keydown", this.handleSkipLink);

      if (this.themeChangeHandler) {
        document.removeEventListener("theme-change", this.themeChangeHandler);
      }

      // Cleanup observers
      this.observer?.disconnect();
      this.resizeObserver?.disconnect();

      // Cancel any pending animations
      if (this.scrollTimeout) {
        cancelAnimationFrame(this.scrollTimeout);
      }

      // Clear references
      this.header = null;
      this.skipLink = null;
      this.observer = null;
      this.resizeObserver = null;
      this.themeChangeHandler = null;
    }
  }

  // Initialize controller
  let controller: HeaderController | null = new HeaderController();

  // Handle Astro page transitions
  document.addEventListener("astro:after-swap", () => {
    controller?.cleanup();
    controller = new HeaderController();
  });

  document.addEventListener("astro:before-swap", () => {
    controller?.cleanup();
    controller = null;
  });
</script>
