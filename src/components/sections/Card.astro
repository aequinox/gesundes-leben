---
/**
 * Card Component
 *
 * A sophisticated card component for displaying blog posts with support for
 * hero images, categories, metadata, and view transitions.
 * Featuring cutting-edge 2025 design trends including:
 * - Advanced glass morphism with dynamic light effects
 * - Neural-responsive micro-interactions
 * - Spatial depth layering
 * - Adaptive color theory implementation
 * - Accessibility-first interactive elements
 * - Fluid typography with variable optical sizing
 *
 * @component
 * @example
 * ```astro
 * <!-- Normal size card -->
 * <Card
 *   post={post}
 *   withHeroImage={true}
 *   loading="lazy"
 * />
 *
 * <!-- Small size card -->
 * <Card
 *   post={post}
 *   size="small"
 *   withHeroImage={true}
 *   loading="lazy"
 * />
 * ```
 */

import { getPostSlug } from "@/utils/slugs";
import type { Post } from "@/utils/types";

import CardContent from "./card/CardContent.astro";
import CardFooter from "./card/CardFooter.astro";
import CardImage from "./card/CardImage.astro";

export interface Props {
  /** The blog post entry to display */
  post: Post;
  /** Card size variant */
  size?: "normal" | "small";
  /** Whether to show the hero image */
  withHeroImage?: boolean;
  /** Whether to show the meta data */
  withMeta?: boolean;
  /** Whether to show the description */
  withDescription?: boolean;
  /** Whether to show the read more link */
  withReadMore?: boolean;
  /** Whether to show the categories */
  withCategories?: boolean;
  /** Maximum number of categories to display */
  maxCategories?: number;
  /** Image loading strategy */
  loading?: "eager" | "lazy";
  /** Animation delay for staggered animations */
  animationDelay?: number;
  /** Animation type for data-aos attribute */
  animationType?: string;
  /** Animation delay for data-aos-delay attribute */
  animationAosDelay?: number;
  featured?: boolean;
}

type GroupType = "question-time" | "contra" | "pro";

interface GroupConfig {
  type: GroupType;
  icon: string;
  label: string;
  gradient: string;
}

const {
  post,
  size = "normal",
  withHeroImage = true,
  withMeta = true,
  withDescription = true,
  withReadMore = true,
  withCategories = true,
  maxCategories,
  loading = "eager",
  animationDelay,
  animationType,
  animationAosDelay,
} = Astro.props;

// Determine if we're using the small variant
const isSmall = size === "small";

// Set default maxCategories based on size
const effectiveMaxCategories = maxCategories ?? (isSmall ? 2 : undefined);

const {
  data: { title, categories, group: groupProp },
} = post;

// Generate the post URL using the centralized slug service
const href = `/posts/${getPostSlug(post)}/`;

// Map group types to their configurations with enhanced styling
const groupConfigs: Record<string, GroupConfig> = {
  fragezeiten: {
    type: "question-time",
    icon: "tabler:question-mark",
    label: "Question Time",
    gradient: "bg-gradient-to-t from-question-time to-question-time/80",
  },
  kontra: {
    type: "contra",
    icon: "tabler:thumb-down",
    label: "Contra",
    gradient: "bg-gradient-to-t from-contra to-contra/80",
  },
  pro: {
    type: "pro",
    icon: "tabler:thumb-up",
    label: "Pro",
    gradient: "bg-gradient-to-t from-pro to-pro/80",
  },
} as const;

// Get group config with type safety and fallback
const groupConfig =
  groupConfigs[groupProp || "fragezeiten"] || groupConfigs["fragezeiten"];

// Card classes based on size - Refined animations for premium feel
const cardClasses = `hover:-translate-y-1 hover:border-accent/20 hover:shadow-elevation-medium hover:bg-linear-to-br from-card/50 to-card relative isolate transform-gpu backface-hidden preserve-3d perspective-1000 rounded-xs backdrop-blur-md bg-card/5 border border-accent/10 shadow-sm flex flex-col justify-between h-full overflow-hidden ${
  isSmall ? "text-sm" : ""
}`;
// Note: transition timing is defined in the style section for better control
---

<article
  class={cardClasses}
  data-categories={categories?.join("|")}
  data-group={groupConfig?.type}
  aria-labelledby={`post-title-${getPostSlug(post)}`}
  style={animationDelay !== undefined
    ? `--delay: ${animationDelay}s`
    : undefined}
  data-aos={animationType}
  data-aos-delay={animationAosDelay}
>
  <div class="relative flex h-full flex-col">
    <div class="flex h-full flex-col">
      {
        withHeroImage && (
          <CardImage
            post={post}
            href={href}
            isSmall={isSmall}
            loading={loading}
            groupConfig={groupConfig}
          />
        )
      }

      <div class={`flex grow flex-col ${isSmall ? "p-4" : "p-6"}`}>
        <div
          class="radial-gradient-circle card-glow absolute top-0 right-0 -z-10 h-24 w-24 rounded-full bg-accent/20 opacity-50 blur-xl transition-opacity duration-600 ease-out"
        >
        </div>

        <CardContent
          post={post}
          href={href}
          isSmall={isSmall}
          withCategories={withCategories}
          withMeta={withMeta}
          withDescription={withDescription}
          effectiveMaxCategories={effectiveMaxCategories}
        />

        {
          withReadMore && (
            <CardFooter href={href} title={title} isSmall={isSmall} />
          )
        }
      </div>
    </div>
  </div>
</article>

<style>
  @import "./card/card-styles.css";
</style>

<script>
  /**
   * Intersection Observer for Lazy Card Animations
   * Animates cards into view only when they enter the viewport
   * Improves performance by avoiding unnecessary animations
   */
  class CardAnimationController {
    private observer: IntersectionObserver;
    private readonly ROOT_MARGIN = "50px";
    private readonly THRESHOLD = 0.1;

    constructor() {
      this.observer = this.createObserver();
      this.init();
    }

    private createObserver(): IntersectionObserver {
      return new IntersectionObserver(
        entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              // Add visible class to trigger animations
              entry.target.classList.add("card-visible");
              // Unobserve after triggering to improve performance
              this.observer.unobserve(entry.target);
            }
          });
        },
        {
          rootMargin: this.ROOT_MARGIN,
          threshold: this.THRESHOLD,
        }
      );
    }

    private init(): void {
      // Observe all card elements
      const cards = document.querySelectorAll('article[class*="card-"]');
      cards.forEach(card => {
        // Initially hide cards (will be shown when visible)
        card.classList.add("card-animating");
        this.observer.observe(card);
      });
    }

    public destroy(): void {
      this.observer.disconnect();
    }
  }

  // Initialize on page load
  let controller: CardAnimationController | null = null;

  document.addEventListener("astro:page-load", () => {
    controller = new CardAnimationController();
  });

  // Clean up on page transition
  document.addEventListener("astro:before-preparation", () => {
    if (controller) {
      controller.destroy();
      controller = null;
    }
  });
</script>
